<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CLASS MANUAL: fourier.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CLASS MANUAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('fourier_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">fourier.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="fourier_8h_source.html">fourier.h</a>&quot;</code><br />
<code>#include &quot;halofit.h&quot;</code><br />
<code>#include &quot;hmcode.h&quot;</code><br />
</div><div class="textblock"><div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Include dependency graph for fourier.c:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="fourier_8c__incl.png" border="0" usemap="#afourier_8c" alt=""/></div>
<map name="afourier_8c" id="afourier_8c">
<area shape="rect" title=" " alt="" coords="839,5,906,32"/>
<area shape="rect" href="fourier_8h.html" title=" " alt="" coords="747,80,814,107"/>
<area shape="rect" title=" " alt="" coords="839,80,906,107"/>
<area shape="rect" title=" " alt="" coords="931,80,1009,107"/>
<area shape="rect" href="primordial_8h.html" title=" " alt="" coords="696,155,785,182"/>
<area shape="rect" href="trigonometric__integrals_8h_source.html" title=" " alt="" coords="861,230,1025,257"/>
<area shape="rect" href="perturbations_8h.html" title=" " alt="" coords="648,230,755,257"/>
<area shape="rect" href="thermodynamics_8h.html" title=" " alt="" coords="596,305,725,332"/>
<area shape="rect" href="background_8h.html" title=" " alt="" coords="220,380,319,407"/>
<area shape="rect" href="evolver__ndf15_8h_source.html" title=" " alt="" coords="473,380,586,407"/>
<area shape="rect" href="evolver__rkck_8h_source.html" title=" " alt="" coords="343,380,450,407"/>
<area shape="rect" title=" " alt="" coords="611,380,710,407"/>
<area shape="rect" href="wrap__recfast_8h_source.html" title=" " alt="" coords="735,380,842,407"/>
<area shape="rect" href="injection_8h_source.html" title=" " alt="" coords="866,380,946,407"/>
<area shape="rect" href="common_8h.html" title=" " alt="" coords="485,530,567,557"/>
<area shape="rect" href="quadrature_8h_source.html" title=" " alt="" coords="30,455,123,482"/>
<area shape="rect" title=" " alt="" coords="147,455,238,482"/>
<area shape="rect" href="arrays_8h_source.html" title=" " alt="" coords="262,455,331,482"/>
<area shape="rect" href="dei__rkck_8h_source.html" title=" " alt="" coords="446,455,528,482"/>
<area shape="rect" href="parser_8h_source.html" title=" " alt="" coords="355,455,422,482"/>
<area shape="rect" title=" " alt="" coords="194,605,255,632"/>
<area shape="rect" title=" " alt="" coords="278,605,341,632"/>
<area shape="rect" title=" " alt="" coords="366,605,427,632"/>
<area shape="rect" title=" " alt="" coords="451,605,515,632"/>
<area shape="rect" title=" " alt="" coords="540,605,597,632"/>
<area shape="rect" href="svnversion_8h_source.html" title=" " alt="" coords="621,605,716,632"/>
<area shape="rect" title=" " alt="" coords="740,605,808,632"/>
<area shape="rect" href="precisions_8h_source.html" title=" " alt="" coords="832,605,923,632"/>
<area shape="rect" href="macros__precision_8h_source.html" title=" " alt="" coords="811,680,945,707"/>
<area shape="rect" href="sparse_8h_source.html" title=" " alt="" coords="603,455,675,482"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abc24df77edd0d387448bc677280d05d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fourier_8c.html#abc24df77edd0d387448bc677280d05d5">fourier_pk_at_z</a> (struct <a class="el" href="structbackground.html">background</a> *pba, struct <a class="el" href="fourier_8h.html#structfourier">fourier</a> *pfo, enum <a class="el" href="primordial_8h.html#af97c57fb2cbf4f53e76a1c0ddfb04322">linear_or_logarithmic</a> mode, enum pk_outputs pk_output, double z, int index_pk, double *out_pk, double *out_pk_ic)</td></tr>
<tr class="separator:abc24df77edd0d387448bc677280d05d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923a2a2b4443953bc7c27bc3bc7aae18"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fourier_8c.html#a923a2a2b4443953bc7c27bc3bc7aae18">fourier_pk_at_k_and_z</a> (struct <a class="el" href="structbackground.html">background</a> *pba, struct <a class="el" href="primordial_8h.html#structprimordial">primordial</a> *ppm, struct <a class="el" href="fourier_8h.html#structfourier">fourier</a> *pfo, enum pk_outputs pk_output, double k, double z, int index_pk, double *out_pk, double *out_pk_ic)</td></tr>
<tr class="separator:a923a2a2b4443953bc7c27bc3bc7aae18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068abe93ced762d7ef98bd9e823a1fe5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fourier_8c.html#a068abe93ced762d7ef98bd9e823a1fe5">fourier_pks_at_kvec_and_zvec</a> (struct <a class="el" href="structbackground.html">background</a> *pba, struct <a class="el" href="fourier_8h.html#structfourier">fourier</a> *pfo, enum pk_outputs pk_output, double *kvec, int kvec_size, double *zvec, int zvec_size, double *out_pk, double *out_pk_cb)</td></tr>
<tr class="separator:a068abe93ced762d7ef98bd9e823a1fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d479c27026c21dbb546768d7dc26eb9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fourier_8c.html#a3d479c27026c21dbb546768d7dc26eb9">fourier_pk_tilt_at_k_and_z</a> (struct <a class="el" href="structbackground.html">background</a> *pba, struct <a class="el" href="primordial_8h.html#structprimordial">primordial</a> *ppm, struct <a class="el" href="fourier_8h.html#structfourier">fourier</a> *pfo, enum pk_outputs pk_output, double k, double z, int index_pk, double *pk_tilt)</td></tr>
<tr class="separator:a3d479c27026c21dbb546768d7dc26eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d971164695b3ba6cd8f979a4d2c65dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fourier_8c.html#a7d971164695b3ba6cd8f979a4d2c65dd">fourier_sigmas_at_z</a> (struct <a class="el" href="common_8h.html#structprecision">precision</a> *ppr, struct <a class="el" href="structbackground.html">background</a> *pba, struct <a class="el" href="fourier_8h.html#structfourier">fourier</a> *pfo, double R, double z, int index_pk, enum out_sigmas sigma_output, double *result)</td></tr>
<tr class="separator:a7d971164695b3ba6cd8f979a4d2c65dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5278691b0d7fcb86db7026fa90a3e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fourier_8c.html#a3a5278691b0d7fcb86db7026fa90a3e7">fourier_k_nl_at_z</a> (struct <a class="el" href="structbackground.html">background</a> *pba, struct <a class="el" href="fourier_8h.html#structfourier">fourier</a> *pfo, double z, double *k_nl, double *k_nl_cb)</td></tr>
<tr class="separator:a3a5278691b0d7fcb86db7026fa90a3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ff3883fa794932936d238b8d7887d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fourier_8c.html#af8ff3883fa794932936d238b8d7887d7">fourier_init</a> (struct <a class="el" href="common_8h.html#structprecision">precision</a> *ppr, struct <a class="el" href="structbackground.html">background</a> *pba, struct <a class="el" href="thermodynamics_8h.html#structthermodynamics">thermodynamics</a> *pth, struct <a class="el" href="perturbations_8h.html#structperturbations">perturbations</a> *ppt, struct <a class="el" href="primordial_8h.html#structprimordial">primordial</a> *ppm, struct <a class="el" href="fourier_8h.html#structfourier">fourier</a> *pfo)</td></tr>
<tr class="separator:af8ff3883fa794932936d238b8d7887d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb01645b8e9d33c73993f5928c1daa8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fourier_8c.html#a8fb01645b8e9d33c73993f5928c1daa8">fourier_free</a> (struct <a class="el" href="fourier_8h.html#structfourier">fourier</a> *pfo)</td></tr>
<tr class="separator:a8fb01645b8e9d33c73993f5928c1daa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0fdabfdbcf8fafb6f7711c286a5af1c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fourier_8c.html#ab0fdabfdbcf8fafb6f7711c286a5af1c">fourier_indices</a> (struct <a class="el" href="common_8h.html#structprecision">precision</a> *ppr, struct <a class="el" href="structbackground.html">background</a> *pba, struct <a class="el" href="perturbations_8h.html#structperturbations">perturbations</a> *ppt, struct <a class="el" href="primordial_8h.html#structprimordial">primordial</a> *ppm, struct <a class="el" href="fourier_8h.html#structfourier">fourier</a> *pfo)</td></tr>
<tr class="separator:ab0fdabfdbcf8fafb6f7711c286a5af1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d67193fe277928c86c710688eb914c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fourier_8c.html#ae8d67193fe277928c86c710688eb914c">fourier_get_k_list</a> (struct <a class="el" href="common_8h.html#structprecision">precision</a> *ppr, struct <a class="el" href="primordial_8h.html#structprimordial">primordial</a> *ppm, struct <a class="el" href="perturbations_8h.html#structperturbations">perturbations</a> *ppt, struct <a class="el" href="fourier_8h.html#structfourier">fourier</a> *pfo)</td></tr>
<tr class="separator:ae8d67193fe277928c86c710688eb914c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd28fc3bdd91a614dc83bfe7381634a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fourier_8c.html#abbd28fc3bdd91a614dc83bfe7381634a">fourier_get_tau_list</a> (struct <a class="el" href="perturbations_8h.html#structperturbations">perturbations</a> *ppt, struct <a class="el" href="fourier_8h.html#structfourier">fourier</a> *pfo)</td></tr>
<tr class="separator:abbd28fc3bdd91a614dc83bfe7381634a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b87b62a00c8cfd643a401be6df328f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fourier_8c.html#a77b87b62a00c8cfd643a401be6df328f">fourier_get_source</a> (struct <a class="el" href="structbackground.html">background</a> *pba, struct <a class="el" href="perturbations_8h.html#structperturbations">perturbations</a> *ppt, struct <a class="el" href="fourier_8h.html#structfourier">fourier</a> *pfo, int index_k, int index_ic, int index_tp, int index_tau, double **sources, double *source)</td></tr>
<tr class="separator:a77b87b62a00c8cfd643a401be6df328f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad261c1985d265df54b75e49df077a9c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fourier_8c.html#ad261c1985d265df54b75e49df077a9c1">fourier_pk_linear</a> (struct <a class="el" href="structbackground.html">background</a> *pba, struct <a class="el" href="perturbations_8h.html#structperturbations">perturbations</a> *ppt, struct <a class="el" href="primordial_8h.html#structprimordial">primordial</a> *ppm, struct <a class="el" href="fourier_8h.html#structfourier">fourier</a> *pfo, int index_pk, int index_tau, int k_size, double *lnpk, double *lnpk_ic)</td></tr>
<tr class="separator:ad261c1985d265df54b75e49df077a9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac909d1cda2d9923a6bafbbfde3e30abb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fourier_8c.html#ac909d1cda2d9923a6bafbbfde3e30abb">fourier_pk_analytic_nowiggle</a> (struct <a class="el" href="common_8h.html#structprecision">precision</a> *ppr, struct <a class="el" href="structbackground.html">background</a> *pba, struct <a class="el" href="primordial_8h.html#structprimordial">primordial</a> *ppm, struct <a class="el" href="fourier_8h.html#structfourier">fourier</a> *pfo)</td></tr>
<tr class="separator:ac909d1cda2d9923a6bafbbfde3e30abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845f409833f2df2c1c1d83205cac02e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fourier_8c.html#a845f409833f2df2c1c1d83205cac02e3">fourier_wnw_split</a> (struct <a class="el" href="common_8h.html#structprecision">precision</a> *ppr, struct <a class="el" href="structbackground.html">background</a> *pba, struct <a class="el" href="primordial_8h.html#structprimordial">primordial</a> *ppm, struct <a class="el" href="fourier_8h.html#structfourier">fourier</a> *pfo)</td></tr>
<tr class="separator:a845f409833f2df2c1c1d83205cac02e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ce9a61f075531ec9b6418d026d6941"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fourier_8c.html#af9ce9a61f075531ec9b6418d026d6941">fourier_sigmas</a> (struct <a class="el" href="fourier_8h.html#structfourier">fourier</a> *pfo, double R, double *lnpk_l, double *ddlnpk_l, int k_size, double k_per_decade, enum out_sigmas sigma_output, double *result)</td></tr>
<tr class="separator:af9ce9a61f075531ec9b6418d026d6941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084d8f8e54f213a933b09cd35f7363c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fourier_8c.html#a084d8f8e54f213a933b09cd35f7363c5">fourier_sigma_at_z</a> (struct <a class="el" href="structbackground.html">background</a> *pba, struct <a class="el" href="fourier_8h.html#structfourier">fourier</a> *pfo, double R, double z, int index_pk, double k_per_decade, double *result)</td></tr>
<tr class="separator:a084d8f8e54f213a933b09cd35f7363c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Documented fourier module</p>
<p>Julien Lesgourgues, 6.03.2014</p>
<p>New module replacing an older one present up to version 2.0 The new module is located in a better place in the main, allowing it to compute non-linear correction to <img class="formulaInl" alt="$ C_l$" src="form_50.png"/>'s and not just <img class="formulaInl" alt="$ P(k)$" src="form_182.png"/>. It will also be easier to generalize to new methods. The old implementation of one-loop calculations and TRG calculations has been dropped from this version, they can still be found in older versions. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="abc24df77edd0d387448bc677280d05d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc24df77edd0d387448bc677280d05d5">&#9670;&nbsp;</a></span>fourier_pk_at_z()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fourier_pk_at_z </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbackground.html">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="fourier_8h.html#structfourier">fourier</a> *&#160;</td>
          <td class="paramname"><em>pfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="primordial_8h.html#af97c57fb2cbf4f53e76a1c0ddfb04322">linear_or_logarithmic</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum pk_outputs&#160;</td>
          <td class="paramname"><em>pk_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_pk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out_pk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out_pk_ic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the P(k,z) for a given redshift z and pk type (_m, _cb) (linear if pk_output = pk_linear, nonlinear if pk_output = pk_nonlinear, nowiggle linear spectrum if pk_output = pk_numerical_nowiggle, analytic approximation to nowiggle linear spectrum if pk_output = pk_analytic_nowiggle)</p>
<p>In the linear case, if there are several initial conditions <em>and</em> the input pointer out_pk_ic is not set to NULL, the function also returns the decomposition into different IC contributions.</p>
<p>In the pk_analytic_nowiggle case, the overall normalisation of the spectrum is currently arbitrary and independent of redhsift.</p>
<p>Hints on input index_pk:</p>
<p>a. if you want the total matter spectrum P_m(k,z), pass in input pfo-&gt;index_pk_total (this index is always defined)</p>
<p>b. if you want the power spectrum relevant for galaxy or halos, given by P_cb if there is non-cold-dark-matter (e.g. massive neutrinos) and to P_m otherwise, pass in input pfo-&gt;index_pk_cluster (this index is always defined)</p>
<p>c. there is another possible syntax (use it only if you know what you are doing): if pfo-&gt;has_pk_m == <em>TRUE</em> you may pass pfo-&gt;index_pk_m to get P_m if pfo-&gt;has_pk_cb == <em>TRUE</em> you may pass pfo-&gt;index_pk_cb to get P_cb</p>
<p>Output format:</p>
<ol type="1">
<li>if mode = logarithmic (most straightforward for the code): out_pk = ln(P(k)) out_pk_ic[diagonal] = ln(P_ic(k)) out_pk_ic[non-diagonal] = cos(correlation angle icxic)</li>
<li>if mode = linear (a conversion is done internally in this function) out_pk = P(k) out_pk_ic[diagonal] = P_ic(k) out_pk_ic[non-diagonal] = P_icxic(k)</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure </td></tr>
    <tr><td class="paramname">pfo</td><td>Input: pointer to fourier structure </td></tr>
    <tr><td class="paramname">mode</td><td>Input: linear or logarithmic </td></tr>
    <tr><td class="paramname">pk_output</td><td>Input: linear, nonlinear, nowiggle... </td></tr>
    <tr><td class="paramname">z</td><td>Input: redshift </td></tr>
    <tr><td class="paramname">index_pk</td><td>Input: index of pk type (_m, _cb) </td></tr>
    <tr><td class="paramname">out_pk</td><td>Output: P(k) returned as out_pk_l[index_k] </td></tr>
    <tr><td class="paramname">out_pk_ic</td><td>Output: P_ic(k) returned as out_pk_ic[index_k * pfo-&gt;ic_ic_size + index_ic1_ic2] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>
<ul>
<li>check whether we need the decomposition into contributions from each initial condition</li>
<li>case z=0 requiring no interpolation in z. The pk_analytic_nowiggle can also be computed here because, in the current implementation, it is only computed at z=0.</li>
<li>interpolation in z</li>
</ul>
<p>--&gt; get value of contormal time tau</p>
<p>-&gt; check that tau is in pre-computed table</p>
<p>--&gt; if ln(tau) much too small, raise an error</p>
<p>--&gt; if ln(tau) too small but within tolerance, round it and get right values without interpolating</p>
<p>--&gt; if ln(tau) much too large, raise an error</p>
<p>--&gt; if ln(tau) too large but within tolerance, round it and get right values without interpolating</p>
<p>-&gt; tau is in pre-computed table: interpolate</p>
<p>--&gt; interpolate P_l(k) at tau from pre-computed array</p>
<p>--&gt; interpolate P_ic_l(k) at tau from pre-computed array</p>
<p>--&gt; we requested P_nl(k) at tau where P_l is computed but the NL correction is NOT -&gt; Return P_l</p>
<p>--&gt; interpolate P_nl(k) at tau from pre-computed array</p>
<p>--&gt; interpolate P_l_nw(k) at tau from pre-computed array</p>
<ul>
<li>so far, all output stored in logarithmic format. Eventually, convert to linear one.</li>
</ul>
<p>--&gt; loop over k</p>
<p>--&gt; convert total spectrum</p>
<p>--&gt; convert contribution of each ic (diagonal elements)</p>
<p>--&gt; convert contribution of each ic (non-diagonal elements)</p>

</div>
</div>
<a id="a923a2a2b4443953bc7c27bc3bc7aae18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923a2a2b4443953bc7c27bc3bc7aae18">&#9670;&nbsp;</a></span>fourier_pk_at_k_and_z()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fourier_pk_at_k_and_z </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbackground.html">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="primordial_8h.html#structprimordial">primordial</a> *&#160;</td>
          <td class="paramname"><em>ppm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="fourier_8h.html#structfourier">fourier</a> *&#160;</td>
          <td class="paramname"><em>pfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum pk_outputs&#160;</td>
          <td class="paramname"><em>pk_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_pk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out_pk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out_pk_ic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the P(k,z) for a given (k,z) and pk type (_m, _cb) (linear if pk_output = pk_linear, nonlinear if pk_output = pk_nonlinear, nowiggle linear spectrum if pk_output = pk_numerical_nowiggle, analytic approximation to linear nowiggle spectrum if pk_output = pk_analytic_nowiggle)</p>
<p>In the linear case, if there are several initial conditions <em>and</em> the input pointer out_pk_ic is not set to NULL, the function also returns the decomposition into different IC contributions.</p>
<p>Hints on input index_pk:</p>
<p>a. if you want the total matter spectrum P_m(k,z), pass in input pfo-&gt;index_pk_total (this index is always defined)</p>
<p>b. if you want the power spectrum relevant for galaxy or halos, given by P_cb if there is non-cold-dark-matter (e.g. massive neutrinos) and to P_m otherwise, pass in input pfo-&gt;index_pk_cluster (this index is always defined)</p>
<p>c. there is another possible syntax (use it only if you know what you are doing): if pfo-&gt;has_pk_m == <em>TRUE</em> you may pass pfo-&gt;index_pk_m to get P_m if pfo-&gt;has_pk_cb == <em>TRUE</em> you may pass pfo-&gt;index_pk_cb to get P_cb</p>
<p>Output format: </p><pre class="fragment">out_pk = P(k)
out_pk_ic[diagonal] = P_ic(k)
out_pk_ic[non-diagonal] = P_icxic(k)
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure </td></tr>
    <tr><td class="paramname">ppm</td><td>Input: pointer to primordial structure </td></tr>
    <tr><td class="paramname">pfo</td><td>Input: pointer to fourier structure </td></tr>
    <tr><td class="paramname">pk_output</td><td>Input: linear, nonlinear, nowiggle... </td></tr>
    <tr><td class="paramname">k</td><td>Input: wavenumber in 1/Mpc </td></tr>
    <tr><td class="paramname">z</td><td>Input: redshift </td></tr>
    <tr><td class="paramname">index_pk</td><td>Input: index of pk type (_m, _cb) </td></tr>
    <tr><td class="paramname">out_pk</td><td>Output: pointer to P </td></tr>
    <tr><td class="paramname">out_pk_ic</td><td>Ouput: P_ic returned as out_pk_ic_l[index_ic1_ic2] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>
<ul>
<li>preliminary: check whether we need the decomposition into contributions from each initial condition</li>
<li>first step: check that k is in valid range [0:kmax] (the test for z will be done when calling fourier_pk_linear_at_z())</li>
<li>deal with case k = 0 for which P(k) is set to zero (this non-physical result can be useful for interpolations)</li>
<li>deal with 0 &lt; k &lt;= kmax</li>
<li>deal with standard case kmin &lt;= k &lt;= kmax</li>
</ul>
<p>--&gt; First, get P(k) at the right z (in logarithmic format for more accurate interpolation, and then convert to linear format)</p>
<p>--&gt; interpolate total spectrum</p>
<p>--&gt; convert from logarithmic to linear format</p>
<p>--&gt; interpolate each ic component</p>
<p>--&gt; convert each ic component from logarithmic to linear format</p>
<p>--&gt; deal with case 0 &lt; k &lt; kmin that requires extrapolation P(k) = [some number] * k * P_primordial(k) so P(k) = P(kmin) * (k P_primordial(k)) / (kmin P_primordial(kmin)) (note that the result is accurate only if kmin is such that [a0 kmin] &lt;&lt; H0)</p>
<p>This is accurate for the synchronous gauge; TODO: write newtonian gauge case. Also, In presence of isocurvature modes, we assumes for simplicity that the mode with index_ic1_ic2=0 dominates at small k: exact treatment should be written if needed.</p>
<p>--&gt; First, get P(k) at the right z (in linear format)</p>

</div>
</div>
<a id="a068abe93ced762d7ef98bd9e823a1fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068abe93ced762d7ef98bd9e823a1fe5">&#9670;&nbsp;</a></span>fourier_pks_at_kvec_and_zvec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fourier_pks_at_kvec_and_zvec </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbackground.html">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="fourier_8h.html#structfourier">fourier</a> *&#160;</td>
          <td class="paramname"><em>pfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum pk_outputs&#160;</td>
          <td class="paramname"><em>pk_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>kvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kvec_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>zvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zvec_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out_pk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out_pk_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the P(k,z) for a grid of (k_i,z_j) passed in input, for all available pk types (_m, _cb), either linear or nonlinear depending on input.</p>
<p>If there are several initial conditions, this function is not designed to return individual contributions.</p>
<p>The main goal of this routine is speed. Unlike <a class="el" href="fourier_8c.html#a923a2a2b4443953bc7c27bc3bc7aae18">fourier_pk_at_k_and_z()</a>, it performs no extrapolation when an input k_i falls outside the pre-computed range [kmin,kmax]: in that case, it just returns P(k,z)=0 for such a k_i</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure </td></tr>
    <tr><td class="paramname">pfo</td><td>Input: pointer to fourier structure </td></tr>
    <tr><td class="paramname">pk_output</td><td>Input: pk_linear, pk_nonlinear, nowiggle... </td></tr>
    <tr><td class="paramname">kvec</td><td>Input: array of wavenumbers in ascending order (in 1/Mpc) </td></tr>
    <tr><td class="paramname">kvec_size</td><td>Input: size of array of wavenumbers </td></tr>
    <tr><td class="paramname">zvec</td><td>Input: array of redshifts in arbitrary order </td></tr>
    <tr><td class="paramname">zvec_size</td><td>Input: size of array of redshifts </td></tr>
    <tr><td class="paramname">out_pk</td><td>Output: P(k_i,z_j) for total matter (if available) in Mpc**3 </td></tr>
    <tr><td class="paramname">out_pk_cb</td><td>Output: P_cb(k_i,z_j) for cdm+baryons (if available) in Mpc**3 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>
<p>Summary:</p>
<ul>
<li>define local variables</li>
<li>Allocate arrays</li>
<li>Construct table of log(P(k_n,z_j)) for pre-computed wavenumbers but requested redshifts:</li>
<li>Spline it for interpolation along k</li>
<li>Construct ln(kvec):</li>
<li>Loop over first k values. If k&lt;kmin, fill output with zeros. If not, go to next step.</li>
<li>Deal with case kmin&lt;=k&lt;=kmax. For better performance, do not loop through kvec, but through pre-computed k values.</li>
</ul>
<p>--&gt; Loop through k_i's that fall in interval [k_n,k_n+1]</p>
<p>--&gt; for each of them, perform spine interpolation</p>
<ul>
<li>Loop over possible remaining k values with k &gt; kmax, to fill output with zeros.</li>
</ul>

</div>
</div>
<a id="a3d479c27026c21dbb546768d7dc26eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d479c27026c21dbb546768d7dc26eb9">&#9670;&nbsp;</a></span>fourier_pk_tilt_at_k_and_z()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fourier_pk_tilt_at_k_and_z </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbackground.html">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="primordial_8h.html#structprimordial">primordial</a> *&#160;</td>
          <td class="paramname"><em>ppm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="fourier_8h.html#structfourier">fourier</a> *&#160;</td>
          <td class="paramname"><em>pfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum pk_outputs&#160;</td>
          <td class="paramname"><em>pk_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_pk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pk_tilt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the logarithmic slope of P(k,z) for a given (k,z), a given pk type (_m, _cb) (computed with linear P_L if pk_output = pk_linear, nonlinear P_NL if pk_output = pk_nonlinear, nowiggle linear spectrum if pk_output = pk_numerical_nowiggle, analytic approximation to linear nowiggle spectrum if pk_output = pk_analytic_nowiggle)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure </td></tr>
    <tr><td class="paramname">ppm</td><td>Input: pointer to primordial structure </td></tr>
    <tr><td class="paramname">pfo</td><td>Input: pointer to fourier structure </td></tr>
    <tr><td class="paramname">pk_output</td><td>Input: linear, nonlinear, nowiggle... </td></tr>
    <tr><td class="paramname">k</td><td>Input: wavenumber in 1/Mpc </td></tr>
    <tr><td class="paramname">z</td><td>Input: redshift </td></tr>
    <tr><td class="paramname">index_pk</td><td>Input: index of pk type (_m, _cb) </td></tr>
    <tr><td class="paramname">pk_tilt</td><td>Output: logarithmic slope of P(k,z) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>

</div>
</div>
<a id="a7d971164695b3ba6cd8f979a4d2c65dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d971164695b3ba6cd8f979a4d2c65dd">&#9670;&nbsp;</a></span>fourier_sigmas_at_z()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fourier_sigmas_at_z </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="common_8h.html#structprecision">precision</a> *&#160;</td>
          <td class="paramname"><em>ppr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbackground.html">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="fourier_8h.html#structfourier">fourier</a> *&#160;</td>
          <td class="paramname"><em>pfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_pk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum out_sigmas&#160;</td>
          <td class="paramname"><em>sigma_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine computes the variance of density fluctuations in a sphere of radius R at redshift z, sigma(R,z), or other similar derived quantitites, for one given pk type (_m, _cb).</p>
<p>The integral is performed until the maximum value of k_max defined in the perturbation module. Here there is not automatic checking that k_max is large enough for the result to be well converged. E.g. to get an accurate sigma8 at R = 8 Mpc/h, the user should pass at least about P_k_max_h/Mpc = 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppr</td><td>Input: pointer to precision structure </td></tr>
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure </td></tr>
    <tr><td class="paramname">pfo</td><td>Input: pointer to fourier structure </td></tr>
    <tr><td class="paramname">R</td><td>Input: radius in Mpc </td></tr>
    <tr><td class="paramname">z</td><td>Input: redshift </td></tr>
    <tr><td class="paramname">index_pk</td><td>Input: type of pk (_m, _cb) </td></tr>
    <tr><td class="paramname">sigma_output</td><td>Input: quantity to be computed (sigma, sigma', ...) </td></tr>
    <tr><td class="paramname">result</td><td>Output: result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>
<ul>
<li>allocate temporary array for P(k,z) as a function of k</li>
<li>get P(k,z) as a function of k, for the right z</li>
<li>spline it along k</li>
<li>calll the function computing the sigmas</li>
<li>free allocated arrays</li>
</ul>

</div>
</div>
<a id="a3a5278691b0d7fcb86db7026fa90a3e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a5278691b0d7fcb86db7026fa90a3e7">&#9670;&nbsp;</a></span>fourier_k_nl_at_z()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fourier_k_nl_at_z </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbackground.html">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="fourier_8h.html#structfourier">fourier</a> *&#160;</td>
          <td class="paramname"><em>pfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>k_nl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>k_nl_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the value of the non-linearity wavenumber k_nl for a given redshift z</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure </td></tr>
    <tr><td class="paramname">pfo</td><td>Input: pointer to fourier structure </td></tr>
    <tr><td class="paramname">z</td><td>Input: redshift </td></tr>
    <tr><td class="paramname">k_nl</td><td>Output: k_nl value </td></tr>
    <tr><td class="paramname">k_nl_cb</td><td>Ouput: k_nl value of the cdm+baryon part only, if there is ncdm </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>
<ul>
<li>convert input redshift into a conformal time</li>
<li>interpolate the precomputed k_nl array at the needed valuetime</li>
<li>if needed, do the same for the baryon part only</li>
</ul>

</div>
</div>
<a id="af8ff3883fa794932936d238b8d7887d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ff3883fa794932936d238b8d7887d7">&#9670;&nbsp;</a></span>fourier_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fourier_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="common_8h.html#structprecision">precision</a> *&#160;</td>
          <td class="paramname"><em>ppr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbackground.html">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="thermodynamics_8h.html#structthermodynamics">thermodynamics</a> *&#160;</td>
          <td class="paramname"><em>pth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="perturbations_8h.html#structperturbations">perturbations</a> *&#160;</td>
          <td class="paramname"><em>ppt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="primordial_8h.html#structprimordial">primordial</a> *&#160;</td>
          <td class="paramname"><em>ppm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="fourier_8h.html#structfourier">fourier</a> *&#160;</td>
          <td class="paramname"><em>pfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the fourier structure, and in particular the nl_corr_density and k_nl interpolation tables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppr</td><td>Input: pointer to precision structure </td></tr>
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure </td></tr>
    <tr><td class="paramname">pth</td><td>Input: pointer to therodynamics structure </td></tr>
    <tr><td class="paramname">ppt</td><td>Input: pointer to perturbation structure </td></tr>
    <tr><td class="paramname">ppm</td><td>Input: pointer to primordial structure </td></tr>
    <tr><td class="paramname">pfo</td><td>Input/Output: pointer to initialized fourier structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>
<ul>
<li>Do we want to compute P(k,z)? Propagate the flag has_pk_matter from the perturbations structure to the fourier structure</li>
<li>preliminary tests</li>
</ul>
<p>--&gt; This module only makes sense for dealing with scalar perturbations, so it should do nothing if there are no scalars</p>
<p>--&gt; Nothing to be done if we don't want the matter power spectrum</p>
<p>--&gt; check applicability of Halofit and HMcode</p>
<ul>
<li>define indices in fourier structure (and allocate some arrays in the structure)</li>
<li>get the linear power spectrum at each time</li>
</ul>
<p>--&gt; loop over required pk types (_m, _cb)</p>
<p>--&gt; get the linear power spectrum for this time and this type</p>
<p>--&gt; one more call to get the linear power spectrum extrapolated up to very large k, for this time and type, but ignoring the case of multiple initial conditions. Result stored in ln_pk_l_extra (different from non-extrapolated ln_pk_l)</p>
<ul>
<li>if interpolation of <img class="formulaInl" alt="$P(k,\tau)$" src="form_183.png"/> will be needed (as a function of tau), compute array of second derivatives in view of spline interpolation</li>
<li>get the analytic_nowiggle power spectrum</li>
<li>get the dewiggled power spectrum at each time in ln_tau</li>
<li>compute and store sigma8 (variance of density fluctuations in spheres of radius 8/h Mpc at z=0, always computed by convention using the linear power spectrum)</li>
<li>get the non-linear power spectrum at each time</li>
</ul>
<p>--&gt; First deal with the case where non non-linear corrections requested</p>
<p>--&gt; Then go through common preliminary steps to the HALOFIT and HMcode methods</p>
<p>--&gt; allocate temporary arrays for spectra at each given time/redshift</p>
<p>--&gt; Then go through preliminary steps specific to HMcode</p>
<p>--&gt; Loop over decreasing time/growing redhsift. For each time/redshift, compute P_NL(k,z) using either Halofit or HMcode</p>
<p>--&gt; spline the array of nonlinear power spectrum (only above the first index where it could be computed)</p>
<p>--&gt; free the nonlinear workspace</p>
<ul>
<li>if the nl_method could not be identified</li>
</ul>

</div>
</div>
<a id="a8fb01645b8e9d33c73993f5928c1daa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb01645b8e9d33c73993f5928c1daa8">&#9670;&nbsp;</a></span>fourier_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fourier_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="fourier_8h.html#structfourier">fourier</a> *&#160;</td>
          <td class="paramname"><em>pfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free all memory space allocated by <a class="el" href="fourier_8c.html#af8ff3883fa794932936d238b8d7887d7">fourier_init()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfo</td><td>Input: pointer to fourier structure (to be freed) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>

</div>
</div>
<a id="ab0fdabfdbcf8fafb6f7711c286a5af1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0fdabfdbcf8fafb6f7711c286a5af1c">&#9670;&nbsp;</a></span>fourier_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fourier_indices </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="common_8h.html#structprecision">precision</a> *&#160;</td>
          <td class="paramname"><em>ppr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbackground.html">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="perturbations_8h.html#structperturbations">perturbations</a> *&#160;</td>
          <td class="paramname"><em>ppt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="primordial_8h.html#structprimordial">primordial</a> *&#160;</td>
          <td class="paramname"><em>ppm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="fourier_8h.html#structfourier">fourier</a> *&#160;</td>
          <td class="paramname"><em>pfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define indices in the fourier structure, and when possible, allocate arrays in this structure given the index sizes found here</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppr</td><td>Input: pointer to precision structure </td></tr>
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure </td></tr>
    <tr><td class="paramname">ppt</td><td>Input: pointer to perturbation structure </td></tr>
    <tr><td class="paramname">ppm</td><td>Input: pointer to primordial structure </td></tr>
    <tr><td class="paramname">pfo</td><td>Input/Output: pointer to fourier structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>
<ul>
<li>define indices for initial conditions (and allocate related arrays)</li>
<li>define flags indices for pk types (_m, _cb). Note: due to some dependencies in HMcode, when pfo-&gt;index_pk_cb exists, it must come first (e.g. the calculation of the non-linear P_m depends on sigma_cb so the cb-related quantitites must be evaluated first)</li>
<li>get list of k values</li>
<li>get list of tau values</li>
<li>given previous indices, we can allocate the array of linear power spectrum values</li>
<li>do we we want to compute and store the analytic_nowiggle power spectrum? This flag was already set by the user in <a class="el" href="input_8c.html">input.c</a>. If we need HMcode, overwrite the user request and compute it. Will soon do the same for Oneloop.</li>
<li>if interpolation of <img class="formulaInl" alt="$P(k,\tau)$" src="form_183.png"/> will be needed (as a function of tau), compute also the array of second derivatives in view of spline interpolation</li>
<li>array of sigma8 values</li>
<li>if non-linear computations needed, allocate array of non-linear correction ratio R_nl(k,z), k_nl(z) and P_nl(k,z) for each P(k) type</li>
<li>allocate arrays for P_nw(k,z) and its splines in log(tau)</li>
</ul>

</div>
</div>
<a id="ae8d67193fe277928c86c710688eb914c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8d67193fe277928c86c710688eb914c">&#9670;&nbsp;</a></span>fourier_get_k_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fourier_get_k_list </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="common_8h.html#structprecision">precision</a> *&#160;</td>
          <td class="paramname"><em>ppr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="primordial_8h.html#structprimordial">primordial</a> *&#160;</td>
          <td class="paramname"><em>ppm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="perturbations_8h.html#structperturbations">perturbations</a> *&#160;</td>
          <td class="paramname"><em>ppt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="fourier_8h.html#structfourier">fourier</a> *&#160;</td>
          <td class="paramname"><em>pfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy list of k from perturbation module, and extended it if necessary to larger k for extrapolation (currently this extrapolation is required only by HMcode)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppr</td><td>Input: pointer to precision structure </td></tr>
    <tr><td class="paramname">ppm</td><td>Input: pointer to primordial structure </td></tr>
    <tr><td class="paramname">ppt</td><td>Input: pointer to perturbation structure </td></tr>
    <tr><td class="paramname">pfo</td><td>Input/Output: pointer to fourier structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>
<ul>
<li>if k extrapolation necessary, compute number of required extra values</li>
<li>otherwise, same number of values as in perturbation module</li>
<li>allocate array of k</li>
<li>fill array of k (not extrapolated)</li>
<li>fill additional values of k (extrapolated)</li>
</ul>

</div>
</div>
<a id="abbd28fc3bdd91a614dc83bfe7381634a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd28fc3bdd91a614dc83bfe7381634a">&#9670;&nbsp;</a></span>fourier_get_tau_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fourier_get_tau_list </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="perturbations_8h.html#structperturbations">perturbations</a> *&#160;</td>
          <td class="paramname"><em>ppt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="fourier_8h.html#structfourier">fourier</a> *&#160;</td>
          <td class="paramname"><em>pfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy list of tau from perturbation module</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppt</td><td>Input: pointer to perturbation structure </td></tr>
    <tr><td class="paramname">pfo</td><td>Input/Output: pointer to fourier structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>
<p>-&gt; for linear calculations: only late times are considered, given the value z_max_pk inferred from the ionput</p>
<p>-&gt; for non-linear calculations: we wills store a correction factor for all times</p>

</div>
</div>
<a id="a77b87b62a00c8cfd643a401be6df328f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b87b62a00c8cfd643a401be6df328f">&#9670;&nbsp;</a></span>fourier_get_source()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fourier_get_source </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbackground.html">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="perturbations_8h.html#structperturbations">perturbations</a> *&#160;</td>
          <td class="paramname"><em>ppt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="fourier_8h.html#structfourier">fourier</a> *&#160;</td>
          <td class="paramname"><em>pfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_ic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get sources for a given wavenumber (and for a given time, type, ic, mode...) either directly from precomputed valkues (computed ain perturbation module), or by analytic extrapolation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure </td></tr>
    <tr><td class="paramname">ppt</td><td>Input: pointer to perturbation structure </td></tr>
    <tr><td class="paramname">pfo</td><td>Input: pointer to fourier structure </td></tr>
    <tr><td class="paramname">index_k</td><td>Input: index of required k value </td></tr>
    <tr><td class="paramname">index_ic</td><td>Input: index of required ic value </td></tr>
    <tr><td class="paramname">index_tp</td><td>Input: index of required tp value </td></tr>
    <tr><td class="paramname">index_tau</td><td>Input: index of required tau value </td></tr>
    <tr><td class="paramname">sources</td><td>Input: array containing the original sources </td></tr>
    <tr><td class="paramname">source</td><td>Output: desired value of source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>
<ul>
<li>use precomputed values</li>
<li>extrapolate</li>
</ul>
<p>--&gt; Get last source and k, which are used in (almost) all methods</p>
<p>--&gt; Get previous source and k, which are used in best methods</p>
<p>--&gt; Extrapolate by assuming the source to vanish Has terrible discontinuity</p>
<p>--&gt; Extrapolate starting from the maximum value, assuming growth ~ ln(k) Has a terrible bend in log slope, discontinuity only in derivative</p>
<p>--&gt; Extrapolate starting from the maximum value, assuming growth ~ ln(k) Here we use k in h/Mpc instead of 1/Mpc as it is done in the CAMB implementation of HMcode Has a terrible bend in log slope, discontinuity only in derivative</p>
<p>--&gt; Extrapolate assuming source ~ ln(a*k) where a is obtained from the data at k_0 Mostly continuous derivative, quite good</p>
<p>--&gt; Extrapolate assuming source ~ ln(e+a*k) where a is estimated like is done in original HMCode</p>
<p>--&gt; If the user has a complicated model and wants to interpolate differently, they can define their interpolation here and switch to using it instead</p>

</div>
</div>
<a id="ad261c1985d265df54b75e49df077a9c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad261c1985d265df54b75e49df077a9c1">&#9670;&nbsp;</a></span>fourier_pk_linear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fourier_pk_linear </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbackground.html">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="perturbations_8h.html#structperturbations">perturbations</a> *&#160;</td>
          <td class="paramname"><em>ppt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="primordial_8h.html#structprimordial">primordial</a> *&#160;</td>
          <td class="paramname"><em>ppm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="fourier_8h.html#structfourier">fourier</a> *&#160;</td>
          <td class="paramname"><em>pfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_pk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>lnpk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>lnpk_ic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine computes all the components of the matter power spectrum P(k), given the source functions and the primordial spectra, at a given time within the pre-computed table of sources (= Fourier transfer functions) of the perturbation module, for a given type (total matter _m or baryon+CDM _cb), and for the same array of k values as in the pre-computed table.</p>
<p>If the input array of k values pfo-&gt;ln_k contains wavemumbers larger than those of the pre-computed table, the sources will be extrapolated analytically.</p>
<p>On the opther hand, if the primordial spectrum has sharp features and needs to be sampled on a finer grid than the sources, this function has to be modified to capture the features.</p>
<p>There are two output arrays, because we consider:</p>
<ul>
<li>the total matter (_m) or CDM+baryon (_cb) power spectrum</li>
<li>in the quantitites labelled _ic, the splitting of one of these spectra in different modes for different initial conditions. If the pointer ln_pk_ic is NULL in input, the function will ignore this part; thus, to get the result, one should allocate the array before calling the function. Then the convention is the following:</li>
</ul>
<p>&ndash; the index_ic1_ic2 labels ordered pairs (index_ic1, index_ic2) (since the primordial spectrum is symmetric in (index_ic1, index_ic2)).</p>
<p>&ndash; for diagonal elements (index_ic1 = index_ic2) this arrays contains ln[P(k)] where P(k) is positive by construction.</p>
<p>&ndash; for non-diagonal elements this arrays contains the k-dependent cosine of the correlation angle, namely P(k)_(index_ic1, index_ic2)/sqrt[P(k)_index_ic1 P(k)_index_ic2]. E.g. for fully correlated or anti-correlated initial conditions, this non-diagonal element is independent on k, and equal to +1 or -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure </td></tr>
    <tr><td class="paramname">ppt</td><td>Input: pointer to perturbation structure </td></tr>
    <tr><td class="paramname">ppm</td><td>Input: pointer to primordial structure </td></tr>
    <tr><td class="paramname">pfo</td><td>Input: pointer to fourier structure </td></tr>
    <tr><td class="paramname">index_pk</td><td>Input: index of required P(k) type (_m, _cb) </td></tr>
    <tr><td class="paramname">index_tau</td><td>Input: index of time </td></tr>
    <tr><td class="paramname">k_size</td><td>Input: wavenumber array size </td></tr>
    <tr><td class="paramname">lnpk</td><td>Output: log of matter power spectrum for given type/time, for all wavenumbers </td></tr>
    <tr><td class="paramname">lnpk_ic</td><td>Output: log of matter power spectrum for given type/time, for all wavenumbers and initial conditions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>
<ul>
<li>allocate temporary vector where the primordial spectrum will be stored</li>
<li>loop over k values</li>
</ul>
<p>--&gt; get primordial spectrum</p>
<p>--&gt; initialize a local variable for P_m(k) and P_cb(k) to zero</p>
<p>--&gt; here we recall the relations relevant for the nomalization fo the power spectrum: For adiabatic modes, the curvature primordial spectrum thnat we just read was: P_R(k) = 1/(2pi^2) k^3 &lt; R R &gt; Thus the primordial curvature correlator is given by: &lt; R R &gt; = (2pi^2) k^-3 P_R(k) So the delta_m correlator reads: P(k) = &lt; delta_m delta_m &gt; = (source_m)^2 &lt; R R &gt; = (2pi^2) k^-3 (source_m)^2 P_R(k)</p>
<p>For isocurvature or cross adiabatic-isocurvature parts, one would just replace one or two 'R' by 'S_i's</p>
<p>--&gt; get contributions to P(k) diagonal in the initial conditions</p>
<p>--&gt; get contributions to P(k) non-diagonal in the initial conditions</p>

</div>
</div>
<a id="ac909d1cda2d9923a6bafbbfde3e30abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac909d1cda2d9923a6bafbbfde3e30abb">&#9670;&nbsp;</a></span>fourier_pk_analytic_nowiggle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fourier_pk_analytic_nowiggle </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="common_8h.html#structprecision">precision</a> *&#160;</td>
          <td class="paramname"><em>ppr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbackground.html">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="primordial_8h.html#structprimordial">primordial</a> *&#160;</td>
          <td class="paramname"><em>ppm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="fourier_8h.html#structfourier">fourier</a> *&#160;</td>
          <td class="paramname"><em>pfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute a smooth analytic approximation to the matter power spectrum today. Store the results in the fourier structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppr</td><td>Input: pointer to precision structure </td></tr>
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure </td></tr>
    <tr><td class="paramname">ppm</td><td>Input: pointer to primordial structure </td></tr>
    <tr><td class="paramname">pfo</td><td>Input/Output: pointer to fourier structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>

</div>
</div>
<a id="a845f409833f2df2c1c1d83205cac02e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845f409833f2df2c1c1d83205cac02e3">&#9670;&nbsp;</a></span>fourier_wnw_split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fourier_wnw_split </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="common_8h.html#structprecision">precision</a> *&#160;</td>
          <td class="paramname"><em>ppr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbackground.html">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="primordial_8h.html#structprimordial">primordial</a> *&#160;</td>
          <td class="paramname"><em>ppm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="fourier_8h.html#structfourier">fourier</a> *&#160;</td>
          <td class="paramname"><em>pfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the decomposition of the linear power spectrum into a wiggly and a non-wiggly part. Store the results in the fourier structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppr</td><td>Input: pointer to precision structure </td></tr>
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure </td></tr>
    <tr><td class="paramname">ppm</td><td>Input: pointer to primordial structure </td></tr>
    <tr><td class="paramname">pfo</td><td>Input/Output: pointer to fourier structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>
<ul>
<li>spline the nowiggle spectrum with respect to time</li>
</ul>

</div>
</div>
<a id="af9ce9a61f075531ec9b6418d026d6941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ce9a61f075531ec9b6418d026d6941">&#9670;&nbsp;</a></span>fourier_sigmas()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fourier_sigmas </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="fourier_8h.html#structfourier">fourier</a> *&#160;</td>
          <td class="paramname"><em>pfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>lnpk_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ddlnpk_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>k_per_decade</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum out_sigmas&#160;</td>
          <td class="paramname"><em>sigma_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate intermediate quantities for hmcode (sigma, sigma', ...) for a given scale R and a given input P(k).</p>
<p>This function has several differences w.r.t. the standard external function non_linear_sigma (format of input, of output, integration stepsize, management of extrapolation at large k, ...) and is overall more precise for sigma(R).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfo</td><td>Input: pointer to fourier structure </td></tr>
    <tr><td class="paramname">R</td><td>Input: scale at which to compute sigma </td></tr>
    <tr><td class="paramname">lnpk_l</td><td>Input: array of ln(P(k)) </td></tr>
    <tr><td class="paramname">ddlnpk_l</td><td>Input: its spline along k </td></tr>
    <tr><td class="paramname">k_size</td><td>Input: dimension of array lnpk_l, normally pfo-&gt;k_size, but inside hmcode it its increased by extrapolation to pfo-&gt;k_extra_size </td></tr>
    <tr><td class="paramname">k_per_decade</td><td>Input: logarithmic step for the integral (recommended: pass ppr-&gt;sigma_k_per_decade) </td></tr>
    <tr><td class="paramname">sigma_output</td><td>Input: quantity to be computed (sigma, sigma', ...) </td></tr>
    <tr><td class="paramname">result</td><td>Output: result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>
<ul>
<li>allocate temporary array for an integral over y(x)</li>
<li>fill the array with values of k and of the integrand</li>
<li>spline the integrand</li>
<li>integrate</li>
<li>preperly normalize the final result</li>
<li>free allocated array</li>
</ul>

</div>
</div>
<a id="a084d8f8e54f213a933b09cd35f7363c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a084d8f8e54f213a933b09cd35f7363c5">&#9670;&nbsp;</a></span>fourier_sigma_at_z()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fourier_sigma_at_z </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbackground.html">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="fourier_8h.html#structfourier">fourier</a> *&#160;</td>
          <td class="paramname"><em>pfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_pk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>k_per_decade</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine computes the variance of density fluctuations in a sphere of radius R at redshift z, sigma(R,z) for one given pk type (_m, _cb).</p>
<p>Try to use instead <a class="el" href="fourier_8c.html#a7d971164695b3ba6cd8f979a4d2c65dd">fourier_sigmas_at_z()</a>. This function is just maintained for compatibility with the deprecated function <a class="el" href="harmonic_8c.html#a3e5acde2947e419e828417896cd786c7">harmonic_sigma()</a></p>
<p>The integral is performed until the maximum value of k_max defined in the perturbation module. Here there is not automatic checking that k_max is large enough for the result to be well converged. E.g. to get an accurate sigma8 at R = 8 Mpc/h, the user should pass at least about P_k_max_h/Mpc = 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure </td></tr>
    <tr><td class="paramname">pfo</td><td>Input: pointer to fourier structure </td></tr>
    <tr><td class="paramname">R</td><td>Input: radius in Mpc </td></tr>
    <tr><td class="paramname">z</td><td>Input: redshift </td></tr>
    <tr><td class="paramname">index_pk</td><td>Input: type of pk (_m, _cb) </td></tr>
    <tr><td class="paramname">k_per_decade</td><td>Input: logarithmic step for the integral (recommended: pass ppr-&gt;sigma_k_per_decade) </td></tr>
    <tr><td class="paramname">result</td><td>Output: result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>
<ul>
<li>allocate temporary array for P(k,z) as a function of k</li>
<li>get P(k,z) as a function of k, for the right z</li>
<li>spline it along k</li>
<li>calll the function computing the sigmas</li>
<li>free allocated arrays</li>
</ul>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_b2f33c71d4aa5e7af42a1ca61ff5af1b.html">source</a></li><li class="navelem"><a class="el" href="fourier_8c.html">fourier.c</a></li>
    <li class="footer">Generated on Mon Feb 17 2025 10:44:54 for CLASS MANUAL by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
